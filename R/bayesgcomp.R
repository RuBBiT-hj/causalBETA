#' Average Treatment Effect Estimation
#' 
#' Takes as input results from bayeshaz() and runs g-computation and returns posteriors draws of the average difference in survival probabilities between the two treatments.
#' By default, survival probabilities and differences are calculated at the midpoints of each of the partitions specified in bayeshaz().
#' @param bayeshaz_object an object of the class `bayeshaz` created by the `bayeshaz()` function
#' @param ref the reference value of the treatment, so it should be one of the treatment values
#' @param B the number of prediction for each posterior draw; the default is 1000
#' @param estimand the statistics in interest; the default is the posterior survival
#' probability at each value of t, `prob`. The other options are the median survival time, `median`, and
#' the Restricted mean survival time, `rmean`.
#' @param t optional; a numeric vector of time points at which users want to compute marginal
#' survival probabilities
#' @param threshold optional; the threshold used for Restricted mean survival time. If not provided,
#' it will use the maximum time of the study as the default
#' survival time as a special case of Restricted mean survival time 
#' @param ... other parameters for estimand function

#' 
#' @details
#' Takes as input a `bayeshaz` object generated by bayeshaz() and runs g-computation and returns posteriors draws of the average difference in survival probabilities between the two treatments.
#' Averaging is done over a Bayesian bootstrap draw of the baseline confounder distribution.
#' 
#' It is important to specify the correct reference level for this function and also other ATE-related
#' ones. Users can specify or change reference by `relevel` function or the `ref` argument in these
#' ATE-related functions. The reference value needs to match the type of treatment variable, and it
#' needs to belong to one of the treatment values.
#' 
#' In addition, users can use argument `t` to specify the time points where they want to estimate 
#' the posterior draws of the average difference of the survival probabilities. If not specified,
#' the function will use the default time points - the midpoints stored in the `bayeshaz` object.
#' 
#' These ATE-related functions only considers binary treatments so it is not applicable for more than two treatment values, or the multiple levels need to be coerced into a
#' binary variable before creating the `bayeshaz` object.
#' 
#' @returns
#' This function returns an object of class `ATE` that stores the following information:
#' 
#' * `surv_ref`, the posterior estimates for the reference
#' * `surv_trt`, the posterior estimates for the treatment

#' * `ref`, the value of the reference treatment
#' * `trt_values`, the possible values of the treatment
#' * `estimand`, the estimand for the ATE
#' * `ATE`, the difference between the marginal survival probability of the treatment and the reference
#' * `t`, the timepoints used for calculating the ATE, specifically for posterior survival probabilities
#' * `threshold`, the threshold used for calculating the Restricted mean survival time. It would be
#' `null` if the estimand is not `rmean`.
#' 
#' @references
#' Ji, Han, and Oganisian, Arman. 2023. 
#' "causalBETA: An R Package for Bayesian Semiparametric Causal Inference with 
#' Event-Time Outcomes. *arXiv:2310.12358 \[Stat\]*, October. 
#' \url{http://arxiv.org/abs/2310.12358}.
#' 
#' @examples
#' \dontrun{
#' # example demo
#' ## Continued from ?bayeshaz
#' gcomp_res = bayesgcomp(post_draws_ar1_adj, ## bayeshaz output 
#'                        ref = 0, ## treatment reference group
#'                        B = 1000, ## monte carlo iterations in g-comp
#'                        estimand = "prob"
#'                        )
#' }

## usethis namespace: start
#' @import coda
#' @import stats 
#' @importFrom mets rpch
#' @importFrom LaplacesDemon rdirichlet
## usethis namespace: end
#' @export


bayesgcomp = function(bayeshaz_object, ref, B = 1000,
                      estimand = "prob",
                      t = NULL, 
                      threshold = NULL,
                      ...){
  
  # calculate the survival probability for each subject at each time
  
  # extract values
  d <- bayeshaz_object$data
  trt <- bayeshaz_object$treatment
  trt_vector <- d[, trt]
  
  beta_draws <- do.call(rbind, bayeshaz_object$beta_draws)
  haz_draws <- do.call(rbind, bayeshaz_object$haz_draws)
  partition <- bayeshaz_object$partition
  covariates <- bayeshaz_object$covariates
  n_draws = nrow(beta_draws)
  
  chains = bayeshaz_object$chains
  
  # check if estimand provided is valid
  if (is.null(estimand)) {
    stop("Estimand provided is NULL")
  } else {
    if ( ! (estimand %in% c("prob", "median", "rmean"))) {
      stop("Estimand provided is not valid")
    }
  }

  
  # check if users provided valid t values
  if (is.null(t)) {
    if (estimand == "prob"){
      t <- bayeshaz_object$midpoint # default
    }
    
  } else {
    # numeric and vector
    if ( !(is.numeric(t) & is.vector(t)) ) {
      stop("t provided should be a numeric vector")
    }
    # not exceed the limit
    if (max(t) > max(partition)) {
      stop("t exceeds the limit of partitions")
    }
  }
  
  # threshold
  if (estimand == "rmean"){
    if (is.null(threshold)){
      threshold = max(partition)
    }
  } else {
    threshold = NULL
  }
  
  # the possible values of the treatment
  trt_values <- unique(trt_vector)
  
  # check that the treatment is binary
  
  if (length(trt_values) !=2 ) stop("Treatment variable needs to be binary")
  
  # check the ref input
  # if the value is one of the treatment variable
  if (!(ref %in% trt_values)) stop("Reference provided is not a valid treatment value")

  # the number of subjects
  n_subject <- nrow(d)
  
  # make two datasets with two treatment values - ref and treatment
  # variables to include - just exclude time and outcome (y and delta)
  var_included <- c(trt, covariates)
  
  d_1 <- subset(d, select = var_included)
  d_1[, trt] <- ref
  
  d_2 <- subset(d, select = var_included)
  d_2[, trt] <- trt_values[trt_values != ref]
  
  # the survival time for the first and the second treatment value
  #   then calculate the difference
  # each matrix is for one subject, and n_draws x n_partitions
  cat(paste0('Running g-comp procedure...','\n'))
  
  # different choices of estimands
    
  ## Posterior survival probability
  if (estimand == "prob") {
    # func = function(y, time_val){mean(y > time_val)}
    phrase = "Survival Probability"
    
    cat(paste0('Calculating Posterior Draws of ', phrase, ' under reference value...',Sys.time(),'\n'))
    surv_est_1 <- lapply(1:n_subject, function(x){
      # call predict.haz as a helper function
      all_surv_time = predict.haz(d_1[x, ], beta_draws, haz_draws, partition, B, func = list)
      # the number of the list - the number of posterior draws
      # the length of each list - the number of predictions (B)
      
      surv_prob <- matrix(nrow = length(all_surv_time),
                          ncol = length(t))
      # For each t, we calculate the proportion
      for (i in 1:length(t)){
        # surv_prob[ ,i] <- sapply(all_surv_time, function(x) mean(x > t[i]))
        # time_val <- t[i]
        surv_prob[ ,i] <- sapply(all_surv_time, function(y, time_val){mean(y > time_val)}, 
                                 time_val = t[i], ...)
      }
      return(surv_prob)
    })
    
    cat(paste0('Calculating Posterior Draws of ', phrase, ' under treatment...',Sys.time(),'\n'))
    surv_est_2 <- lapply(1:n_subject, function(x){
      # call predict.haz as a helper function
      all_surv_time = predict.haz(d_2[x, ], beta_draws, haz_draws, partition, B, func = list)
      # the number of the list - the number of posterior draws
      # the length of each list - the number of predictions (B)
      surv_prob <- matrix(nrow = length(all_surv_time),
                          ncol = length(t))
      # For each t, we calculate the proportion
      for (i in 1:length(t)){
        # surv_prob[ ,i] <- sapply(all_surv_time, function(x) mean(x > t[i]))
        # time_val <- t[i]
        surv_prob[ ,i] <- sapply(all_surv_time, function(y, time_val){mean(y > time_val)}, 
                                 time_val = t[i], ...)
      }
      return(surv_prob)
    })
    
    cat(paste0('Calculating Posterior Draws of ', phrase, ' Difference...',Sys.time(),'\n'))
    surv_prob_diff <- lapply(1:n_subject, function(i){
      return(surv_est_2[[i]] - surv_est_1[[i]])
    })
    
    # calculate the posterior estimands for each treatment and posterior ATE
    surv_1_post <- matrix(nrow = n_draws,
                          ncol = length(t))
    surv_2_post <- matrix(nrow = n_draws,
                          ncol = length(t))
    ATE <- matrix(nrow = n_draws,
                  ncol = length(t))
    
    # alpha vector for rdirichlet
    alpha <- rep(1, n_subject)
    
    cat(paste0('Computing Bayesian Bootstrap Weighted Average...',Sys.time(),'\n'))
    
    for (i in 1:n_draws){
      
      # draw Dirichlet for weighted sum
      weights_dir <- matrix(LaplacesDemon::rdirichlet(1, alpha = alpha), ncol = 1)
      
      surv_1_post[i, ] <- sapply(surv_est_1, function(x) x[i,]) %*% weights_dir
      surv_2_post[i, ] <- sapply(surv_est_2, function(x) x[i,]) %*% weights_dir
      ATE[i, ] <- sapply(surv_prob_diff, function(x) x[i,]) %*% weights_dir
    }
    
    # Posterior median survival time
  } else if (estimand == "median") {
    phrase = "Median Survival Time"
    
    cat(paste0('Calculating Posterior Draws of ', phrase, ' under reference value...',Sys.time(),'\n'))
    surv_est_1 <- lapply(1:n_subject, function(x){
      # call predict.haz as a helper function
      all_surv_time = predict.haz(d_1[x, ], beta_draws, haz_draws, partition, B, func = list)
      # the number of the list - the number of posterior draws
      # the length of each list - the number of predictions (B)


      surv_prob <- sapply(all_surv_time, median, ...)
      surv_prob <- matrix(surv_prob, nrow = length(all_surv_time))
      
      return(surv_prob)
    })
    
    cat(paste0('Calculating Posterior Draws of ', phrase, ' under treatment...',Sys.time(),'\n'))
    surv_est_2 <- lapply(1:n_subject, function(x){
      # call predict.haz as a helper function
      all_surv_time = predict.haz(d_1[x, ], beta_draws, haz_draws, partition, B, func = list)
      # the number of the list - the number of posterior draws
      # the length of each list - the number of predictions (B)
      
      surv_prob <- sapply(all_surv_time, median, ...)
      surv_prob <- matrix(surv_prob, nrow = length(all_surv_time))
      return(surv_prob)
    })
    
    cat(paste0('Calculating Posterior Draws of ', phrase, ' Difference...',Sys.time(),'\n'))
    surv_prob_diff <- lapply(1:n_subject, function(i){
      return(surv_est_2[[i]] - surv_est_1[[i]])
    })
    
    # calculate the posterior estimands for each treatment and posterior ATE
    surv_1_post <- matrix(nrow = n_draws,
                          ncol = 1)
    surv_2_post <- matrix(nrow = n_draws,
                          ncol = 1)
    ATE <- matrix(nrow = n_draws,
                  ncol = 1)
    # alpha vector for rdirichlet
    alpha <- rep(1, n_subject)
    
    cat(paste0('Computing Bayesian Bootstrap Weighted Average...',Sys.time(),'\n'))
    
    for (i in 1:n_draws){
      
      # draw Dirichlet for weighted sum
      weights_dir <- matrix(LaplacesDemon::rdirichlet(1, alpha = alpha), ncol = 1)
      
      surv_1_post[i, 1] <- sapply(surv_est_1, function(x) x[i,]) %*% weights_dir
      surv_2_post[i, 1] <- sapply(surv_est_2, function(x) x[i,]) %*% weights_dir
      ATE[i, 1] <- sapply(surv_prob_diff, function(x) x[i,]) %*% weights_dir
    }
    # Restricted Mean
  } else { 
    phrase = "Restricted Mean Survival Time"
    
    
    cat(paste0('Calculating Posterior Draws of ', phrase, ' under reference value...',Sys.time(),'\n'))
    surv_est_1 <- lapply(1:n_subject, function(x){
      # call predict.haz as a helper function
      all_surv_time = predict.haz(d_1[x, ], beta_draws, haz_draws, partition, B, func = list)
      # the number of the list - the number of posterior draws
      # the length of each list - the number of predictions (B)
      
      surv_prob <- sapply(all_surv_time, function(y){mean(pmin(y, threshold))}, ...)
      surv_prob <- matrix(surv_prob, nrow = length(all_surv_time))
      
      return(surv_prob)
    })
    
    cat(paste0('Calculating Posterior Draws of ', phrase, ' under treatment...',Sys.time(),'\n'))
    surv_est_2 <- lapply(1:n_subject, function(x){
      # call predict.haz as a helper function
      all_surv_time = predict.haz(d_1[x, ], beta_draws, haz_draws, partition, B, func = list)
      # the number of the list - the number of posterior draws
      # the length of each list - the number of predictions (B)
      
      surv_prob <- sapply(all_surv_time, function(y){mean(pmin(y, threshold))}, ...)
      surv_prob <- matrix(surv_prob, nrow = length(all_surv_time))
      return(surv_prob)
    })
    
    cat(paste0('Calculating Posterior Draws of ', phrase, ' Difference...',Sys.time(),'\n'))
    surv_prob_diff <- lapply(1:n_subject, function(i){
      return(surv_est_2[[i]] - surv_est_1[[i]])
    })
    
    # calculate the posterior estimands for each treatment and posterior ATE
    surv_1_post <- matrix(nrow = n_draws,
                          ncol = 1)
    surv_2_post <- matrix(nrow = n_draws,
                          ncol = 1)
    ATE <- matrix(nrow = n_draws,
                  ncol = 1)
    # alpha vector for rdirichlet
    alpha <- rep(1, n_subject)
    
    cat(paste0('Computing Bayesian Bootstrap Weighted Average...',Sys.time(),'\n'))
    
    for (i in 1:n_draws){
      
      # draw Dirichlet for weighted sum
      weights_dir <- matrix(LaplacesDemon::rdirichlet(1, alpha = alpha), ncol = 1)
      
      surv_1_post[i, 1] <- sapply(surv_est_1, function(x) x[i,]) %*% weights_dir
      surv_2_post[i, 1] <- sapply(surv_est_2, function(x) x[i,]) %*% weights_dir
      ATE[i, 1] <- sapply(surv_prob_diff, function(x) x[i,]) %*% weights_dir
    }
  }
  
  # # of draws per chain
  n_draws_chain = n_draws/chains
  surv_1_post_list = list(); surv_2_post_list = list(); ATE_list = list()
  
  # break into mcmc list
  for (i in 1:chains){
    start_index = (i-1)*n_draws_chain + 1
    end_index = i*n_draws_chain
    surv_1_post_list[[i]] = coda::mcmc(surv_1_post[start_index:end_index,], 
                                       start = 1, end = n_draws_chain, thin = 1)
    surv_2_post_list[[i]] = coda::mcmc(surv_2_post[start_index:end_index,], 
                                       start = 1, end = n_draws_chain, thin = 1)
    ATE_list[[i]] = coda::mcmc(ATE[start_index:end_index,], 
                                       start = 1, end = n_draws_chain, thin = 1)
  }
  
  
  surv_1_post = do.call(coda::mcmc.list, surv_1_post_list)
  surv_2_post = do.call(coda::mcmc.list, surv_2_post_list)
  ATE = do.call(coda::mcmc.list, ATE_list)
  
  

  
  ATE_object = create_ATE(surv_ref = surv_1_post, surv_trt = surv_2_post, 
                          trt_values = c(ref, trt_values[trt_values != ref]), 
                          estimand = estimand, ref = ref, ATE = ATE, t = t,
                          threshold = threshold)
  
  cat(paste0('g-comp complete...',Sys.time(),'\n'))
  
  return(ATE_object)
}
